# 基本ルール

- このプロジェクトでは日本語を基本言語とします。
- アウトプットも必ず日本語を使用してください。
- プロジェクトフォルダを超えた領域にアクセスしたりファイル/フォルダを作成することを禁止します。

# 開発ルール

## 仕様とタスク管理

本プロジェクトの開発は、以下のドキュメントに基づき進めます。

- **仕様**: プロジェクトの仕様は、`.kiro/specs/taco-pmo-assistant/` ディレクトリ内の `requirements.md`（要件定義）および `design.md`（設計書）に基づきます。開発に着手する前に、必ずこれらのドキュメントを確認してください。
- **タスク管理**: 具体的な開発タスクは `.kiro/specs/taco-pmo-assistant/tasks.md` に記載されています。開発作業は、このファイルで定義されたタスクをベースに進めてください。

## ブランチ管理とコミットルール

新しい動作や機能を追加する際は、以下のルールに従ってブランチを作成し、随時コミットを行いながら変更を加えてください。

### 1. ブランチ作成ルール

- **機能追加時**: `feature/機能名` 形式でブランチを作成
  ```bash
  git checkout -b feature/新機能名
  ```

- **バグ修正時**: `fix/修正内容` 形式でブランチを作成
  ```bash
  git checkout -b fix/バグ修正内容
  ```

- **リファクタリング時**: `refactor/リファクタリング内容` 形式でブランチを作成
  ```bash
  git checkout -b refactor/リファクタリング内容
  ```

### 2. コミットルール

- **頻繁なコミット**: 小さな変更でも随時コミットを行う
- **明確なコミットメッセージ**: 英語で変更内容を具体的に記述
  ```bash
  git commit -m "feat: add user authentication feature"
  git commit -m "fix: improve login error handling"
  git commit -m "refactor: improve code readability"
  ```

### 3. 開発ワークフロー

機能追加やバグ修正を行う際は、以下のワークフローに従ってください。

1.  **Issueの作成**:
    -   開発に着手する前に、タスク内容を整理し、適切な粒度でGitHub Issueを作成します。

2.  **ブランチの作成**:
    -   Issueに対応するブランチを、命名規則（`feature/機能名`, `fix/修正内容`など）に従って作成します。

3.  **実装とテスト**:
    -   機能の実装と並行して、必ずテストコードを実装します。
    -   タスクの完了は、実装したテストがすべて成功（パス）することを条件とします。

4.  **コミット**:
    -   変更は小さな単位で、コミットメッセージのルールに従って頻繁にコミットします。

5.  **Pull Requestの作成**:
    -   テストが成功し、実装が完了したら、`main`ブランチへのPull Requestを作成します。
    -   Pull Requestの概要には、対応するIssue番号を記載します（例: `Closes #123`）。

6.  **マージとIssueのクローズ**:
    -   コードレビューを経て、Pull Requestが`main`ブランチにマージされると、関連するIssueは自動的にクローズされます。

7.  **ブランチの削除**:
    -   マージ後、不要になった作業ブランチは削除します。

### 4. コミットメッセージの例

- `feat: 新しい機能を追加`
- `fix: バグを修正`
- `docs: ドキュメントを更新`
- `style: コードスタイルを修正`
- `refactor: コードをリファクタリング`
- `test: テストを追加`
- `chore: 設定ファイルを更新`

# Taco プロジェクト

このプロジェクトは、Slackの複数チャンネルの会話内容を分析し、デイリーレポートとタスクリストを自動生成することを目的としています。

## 目的

日々のコミュニケーションからタスクや進捗状況を自動的に集約し、チームの状況把握を効率化します。

## ディレクトリ構造

- `.cursor/`: Cursor IDE固有の設定ファイルが保存されます。主にAIチャットの振る舞いを定義するルールファイルが含まれます。
- `reports/daily/`: 生成されたデイリーレポート（Markdown形式）が保存されます。
- `reports/weekly/`: 生成されたウィークリーレポート（Markdown形式）が保存されます。
- `reports/raw/`: Slackから取得した生のメッセージデータ（JSON形式）が保存されます。
- `tasks.md`: 最新のタスクリストが保存されます。

### ファイル名規則
- **デイリーレポート**: `YYYY-MM-DD.md`
- **ウィークリーレポート**: `YYYY-MM-DD_YYYY-MM-DD_weekly.md` (開始日_終了日_weekly.md)
- **生データ**: `raw_messages_チャンネルID_YYYY-MM-DD.json`

## デイリーレポート生成手順

以下のコマンドを実行することで、Slackから過去1週間分のメッセージが取得され、`reports/raw/` ディレクトリに日付ごとのJSONファイルとして保存されます。

1. **仮想環境のアクティベート**
   ```bash
   # このプロジェクトでは、スクリプトが仮想環境のPythonを直接呼び出すため、手動でのアクティベートは不要です。
   ```

2. **生データ取得スクリプトの実行**
   ```bash
   ./run_daily_report.sh
   ```

## ウィークリーレポート生成手順

ウィークリーレポートは、Gemini CLI (私) が `reports/daily/` ディレクトリ内の過去1週間分のデイリーレポートを直接読み込み、分析して生成します。

ウィークリーレポートの生成を依頼するには、Gemini CLI (私) に直接指示してください。
例: `過去1週間分のデイリーレポートを元に、ウィークリーレポートを作成してください。`

## レポート処理フロー

`./run_daily_report.sh` の実行後、Gemini CLI (私) が `reports/raw/` ディレクトリ内の各JSONファイルを読み込み、以下の処理を自動的に行います。

1. 各JSONファイルの内容を分析し、デイリーレポート（Markdown形式）を生成します。
2. 生成されたデイリーレポートは `reports/daily/YYYY-MM-DD.md` として保存されます。
3. 最新のデイリーレポートからタスクリストを抽出し、プロジェクトルートの `tasks.md` を最新の状態に更新します。

### 必要な環境変数

スクリプトの実行には、プロジェクトのルートディレクトリに `.env` ファイルを配置し、以下の変数を設定する必要があります。

- `SLACK_API_TOKEN`: Slack BotのOAuthトークン (`xoxb-...`)
- `SLACK_CHANNEL_IDS`: 監視対象のSlackチャンネルID（カンマ区切りで複数指定可） (`C...`)

### 注意事項

- レポートの分析と生成はGemini CLI (私) が行います。`main.py` はメッセージの取得と保存に特化しています。
- `tasks.md` と `reports/` ディレクトリは `.gitignore` に追加されており、Gitの追跡対象外です。